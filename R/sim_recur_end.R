#' Simulate recurrent event data with unobserved terminating event
#'
#' @param n integer, sample size of independent subjects
#' @param lambda_d numeric value > 0, rate of exponentially distributed
#' terminating event
#' @param lambda_r numeric value > 0, baseline rate of recurrent event process
#' @param sigma2 numeric value >= 0, variance of gamma-distributed random effect
#' for the recurrent event process
#' @param cov_fun function of the form \code{function(n,...)} that generates a
#' model matrix of covariates for \code{n} subjects. Set to NULL if no covariates
#' are used.
#' @param beta numeric vector with the coefficients of the covariates generated
#' by \code{cov_fun}. Ignored if \code{cov_fun} is NULL.
#' @param lambda_c numeric value > 0, rate of censoring distribution after minimal
#' follow-up time \code{C_min}
#' @param C_min numeric value >=0, minimal follow-up time without censoring
#' @param censored.ok logical, indicating whether subjects with first event censored
#' (ie `nevents=0`) should be retained
#' @param ... optional parameters passed to \code{cov_fun}
#' @importFrom stats rexp rgamma runif uniroot
#' @returns A data frame with the simulated event times and the values
#' of the unobservable underlying variables:
#' \describe{
#'   \item{patient.id}{int Patient ID}
#'   \item{nevents}{int Number of observed recurrent events for the patient}
#'   \item{time}{dbl Observation time of a recurrent event or censoring}
#'   \item{indicator}{int Event indicator. 1 - recurrent event, 0 - censoring}
#'   \item{recurrence_end}{dbl _Unobservable_ end-time of the recurrent event process}
#'   \item{C}{dbl Censoring time}
#'   \item{xi}{dbl _Unobservable_ subject-specific frailty of the
#'             recurrent event process}
#'   \item{Z.1, Z.2, ...}{the values of the covariates generated by \code{cov_fun}}
#'   }
#' @export
#' @examples
#' simd <- sim_recur_end(n=10, lambda = 1, lambda_r = 5, sigma2=0.1,
#'    cov_fun = function(n)cbind(rbinom(n, size=1, prob = 0.5),
#'                               rnorm(n)),
#'    beta = c(0,0.2), lambda_c = 1, C_min = 1)
#'

sim_recur_end <- function(n, lambda_d, lambda_r, sigma2, lambda_c, C_min=0,
                          cov_fun=NULL, beta=NULL, censored.ok=TRUE, ...) {
  # generate covariates for the recurrent process rate
  if (!is.null(cov_fun)){
    Z <- as.matrix(cov_fun(n, ...))
    if (ncol(Z) != length(beta))
      stop("The covariate matrix generated by 'cov_fun' should have number of columns
           equal to the length of coefficient vector 'beta'")
    linpred <- drop(Z %*% beta)}
  else {
    linpred <- rep(0, n)
    Z <- NULL
    }

  # generate subject-specific random effect for recurrent process
   if (sigma2 == 0) {
    xi <- rep(1,n)
  } else {
    xi <- stats::rgamma(n, shape = 1/sigma2, scale = sigma2)
  }
  # ensure that recurrent event rate is always less than terminal event rate
  xi <- pmax(xi, min(lambda_d/(lambda_r*exp(linpred))))
  # recurrent event rate for each subject
  r <- xi * lambda_r * exp(linpred)

  # generate first event times
  tau1 <- stats::rexp(n, rate = r)
  # Generate censoring times
  C <- C_min + stats::rexp(n, rate = lambda_c)

  if (!censored.ok){
    uncens <- (tau1 <= C)
    tau1 <- tau1[uncens]
    C <- C[uncens]
    while (length(tau1) < n){
      tau1_new <- stats::rexp(n - length(tau1), rate = r)
      C_new <- C_min + stats::rexp(n - length(tau1), rate = lambda_c)
      uncens_new <- (tau1_new <= C_new)
      tau1 <- c(tau1, tau1_new[uncens_new])
      C <- c(C, C_new[uncens_new])
    }
  }

  # generate terminating event, conditional on being larger than first event
  y <- stats::runif(n, min = 0, max = 1)
  upper_lim <- -log(1-y)/lambda_d
  # inverse CDF solver
  f.t.tilde <- function(i) {
      if (y[i] <= lambda_d/r[i]) {
        return(0)
      } else {
        res <- stats::uniroot(
          function(t) {
            (1 - exp(-lambda_d * t)) / (1 - exp(-r[i] * t)) - y[i]
          },  c(10^-7, upper_lim[i]), extendInt = "upX"
        )
        return(res$root)
      }
  }

  tau_tilde <- numeric(n)
  for (i in 1:n){
    tau_tilde[i] <- f.t.tilde(i)
  }
  recurrence_end <- pmax(tau1, tau_tilde)


  data_list <- list()
  # Loop over subjects to generate recurrent and terminal events
  for (i in 1:n) {
    # first event time has already been generated
    current_time <- tau1[i]
    event_times <- c()
    while (current_time <= min(recurrence_end[i], C[i])){
      event_times <- c(event_times, current_time)
      current_time <- current_time + stats::rexp(1, rate=r[i])
    }
    # create recurrent events for this subject
    # last event is censoring
    if (!is.null(cov_fun)){
      subj_data <- data.frame(
        patient.id = i,
        nevents = length(event_times),
        time = c(event_times, C[i]),
        indicator = c(rep(1, length(event_times)), 0),
        recurrence_end = recurrence_end[i],
        C = C[i],
        xi = xi[i],
        Z = Z[i, ,drop=FALSE]
      )
    } else {
      subj_data <- data.frame(
        patient.id = i,
        nevents = length(event_times),
        time = c(event_times, C[i]),
        indicator = c(rep(1, length(event_times)), 0),
        recurrence_end = recurrence_end[i],
        C = C[i],
        xi = xi[i])
    }
    data_list <- c(data_list, list(subj_data))
  }

  simdat <- do.call(rbind, data_list)
  simdat
}
