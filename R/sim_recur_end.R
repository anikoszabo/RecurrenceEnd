#' Simulate recurrent event data with unobserved terminating event
#'
#' @param n integer, sample size of independent subjects
#' @param lambda_d numeric value > 0, rate of exponentially distributed
#' terminating event
#' @param lambda_r numeric value > 0, baseline rate of recurrent event process
#' @param sigma2 numeric value >= 0, variance of gamma-distributed random effect
#' for the recurrent event process
#' @param cov_fun function of the form \code{function(n,...)} that generates a
#' model matrix of covariates for \code{n} subjects
#' @param beta numeric vector with the coefficients of the covariates generated
#' by \code{cov_fun}
#' @param lambda_c numeric value > 0, rate of censoring distribution after minimal
#' follow-up time \code{C_min}
#' @param C_min numeric value >=0, minimal follow-up time without censoring
#' @param ... optional parameters passed to \code{cov_fun}
#' @importFrom stats rexp rgamma runif uniroot
#' @returns A data frame with the simulated event times and the values
#' of the unobservable underlying variables:
#' \describe{
#'   \item{patient.id}{int Patient ID}
#'   \item{nevents}{int Number of observed recurrent events for the patient}
#'   \item{time}{dbl Observation time of a recurrent event or censoring}
#'   \item{indicator}{int Event indicator. 1 - recurrent event, 0 - censoring}
#'   \item{recurrence_end}{dbl _Unobservable_ end-time of the recurrent event process}
#'   \item{C}{dbl Censoring time}
#'   \item{xi}{dbl _Unobservable_ subject-specific frailty of the
#'             recurrent event process}
#'   \item{Z.1, Z.2, ...}{the values of the covariates generated by \code{cov_fun}}
#'   }
#' @export
#' @examples
#' simd <- sim_recur_end(n=10, lambda = 1, lambda_r = 5, sigma2=0.1,
#'    cov_fun = function(n)cbind(rbinom(n, size=1, prob = 0.5),
#'                               rnorm(n)),
#'    beta = c(0,0.2), lambda_c = 1, C_min = 1)
#'

sim_recur_end <- function(n, lambda_d, lambda_r, sigma2,
                          cov_fun, beta, lambda_c, C_min=0, ...) {
  # generate covariates for the recurrent process rate
  Z <- as.matrix(cov_fun(n, ...))
  if (ncol(Z) != length(beta))
    stop("The covariate matrix generated by 'cov_fun' should have number of columns
         equal to the length of coefficient vector 'beta'")
  linpred <- drop(Z %*% beta)

  # generate subject-specific random effect for recurrent process
   if (sigma2 == 0) {
    xi <- rep(1,n)
  } else {
    xi <- stats::rgamma(n, shape = 1/sigma2, scale = sigma2)
  }
  # ensure that recurrent event rate is always less than terminal event rate
  xi <- pmax(xi, min(lambda_d/(lambda_r*exp(linpred))))
  # recurrent event rate for each subject
  r <- xi * lambda_r * exp(linpred)

  # generate first event times
  tau1 <- stats::rexp(n, rate = r)
  # generate terminating event, conditional on being larger than first event
  y <- stats::runif(n, min = 0, max = 1)
  upper_lim <- -log(1-y)/lambda_d
  # inverse CDF solver
  f.t.tilde <- function(i) {
      if (y[i] <= lambda_d/r[i]) {
        return(0)
      } else {
        res <- stats::uniroot(
          function(t) {
            (1 - exp(-lambda_d * t)) / (1 - exp(-r[i] * t)) - y[i]
          },  c(10^-7, upper_lim[i]), extendInt = "upX"
        )
        return(res$root)
      }
  }

  tau_tilde <- numeric(n)
  for (i in 1:n){
    tau_tilde[i] <- f.t.tilde(i)
  }
  recurrence_end <- pmax(tau1, tau_tilde)

  # Generate censoring times
  C = C_min + stats::rexp(n, rate = lambda_c)
  #C_tilde = C_min + rexp(n, rate = lambda_c)
  #C <- pmax(tau1, C_tilde)

  data_list <- list()
  # Loop over subjects to generate recurrent and terminal events
  for (i in 1:n) {
    # first event time has already been generated
    current_time <- tau1[i]
    event_times <- c()
    while (current_time <= min(recurrence_end[i], C[i])){
      event_times <- c(event_times, current_time)
      current_time <- current_time + stats::rexp(1, rate=r[i])
    }
    # create recurrent events for this subject
    # last event is censoring
    subj_data <- data.frame(
      patient.id = i,
      nevents = length(event_times),
      time = c(event_times, C[i]),
      indicator = c(rep(1, length(event_times)), 0),
      recurrence_end = recurrence_end[i],
      C = C[i],
      xi = xi[i],
      Z = Z[i, ,drop=FALSE]
    )
    data_list <- c(data_list, list(subj_data))
  }

  simdat <- do.call(rbind, data_list)
  simdat
}
