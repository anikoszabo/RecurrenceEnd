#' Simulate recurrent event data with unobserved terminating event
#'
#' @param n integer, sample size of independent subjects
#' @param lambda_d numeric value > 0, rate of exponentially distributed
#' terminating event
#' @param lambda_r numeric value > 0, baseline rate of recurrent event process
#' @param sigma2 numeric value >= 0, variance of gamma-distributed random effect
#' for the recurrent event process
#' @param cov_fun function of the form \code{function(n,...)} that generates a
#' model matrix of covariates for \code{n} subjects
#' @param beta numeric vector with the coefficients of the covariates generated
#' by \code{cov_fun}
#' @param lambda_c numeric value > 0, rate of censoring distribution after minimal
#' follow-up time \code{C_min}
#' @param C_min numeric value >=0, minimal follow-up time without censoring
#' @param ... optional parameters passed to \code{cov_fun}

sim_recur_end <- function(n, lambda_d, lambda_r, sigma2,
                          cov_fun, beta, lambda_c, C_min=0, ...) {
  # generate covariates for the recurrent process rate
  Z <- as.matrix(cov_fun(n, ...))
  if (ncol(Z) != length(beta))
    stop("The covariate matrix generated by 'cov_fun' should have number of columns
         equal to the length of coefficient vector 'beta'")
  linpred <- drop(Z %*% beta)

  # generate subject-specific random effect for recurrent process
   if (sigma2 == 0) {
    xi <- rep(1,n)
  } else {
    xi <- rgamma(n, shape = 1/sigma2, scale = sigma2)
  }
  # ensure that recurrent event rate is always less than terminal event rate
  xi <- pmax(xi, min(lambda_d/(lambda_r*exp(linpred))))
  # recurrent event rate for each subject
  r <- xi * lambda_r * exp(linpred)

  # generate first event times
  tau1 <- rexp(n, rate = r)
  # generate terminating event, conditional on being larger than first event
  y <- runif(n, min = 0, max = 1)
  upper_lim <- -log(1-y)/lambda_d
  # inverse CDF solver
  f.t.tilde <- function(i) {
      if (y[i] <= lambda_d/r[i]) {
        return(0)
      } else {
        res <- uniroot(
          function(t) {
            (1 - exp(-lambda_d * t)) / (1 - exp(-r[i] * t)) - y[i]
          },  c(10^-7, upper_lim[i]), extendInt = "upX"
        )
        return(res$root)
      }
  }

  tau_tilde <- numeric(n)
  for (i in 1:n){
    tau_tilde[i] <- f.t.tilde(i)
  }
  disease_onset <- pmax(tau1, tau_tilde)

  # Generate censoring times, without censoring first recurrent event
  C_tilde = C_min + rexp(n, rate = lambda_c)
  C <- pmax(tau1, C_tilde)


  # Initialize an empty dataframe to store the observed time and status for each patient
 # observed_data <- data.frame(patient_id = integer(), time = numeric(),
#                              indicator = integer(), Z = integer(),
#                              minimum = numeric(), disease_onset = numeric(),
#                              C = numeric(), xi = numeric())

  data_list <- list()
  # Loop over subjects to generate recurrent and terminal events
  for (i in 1:n) {
    # first event time has already been generated
    current_time <- tau1[i]
    event_times <- c()
    while (current_time <= min(disease_onset[i], C[i])){
      event_times <- c(event_times, current_time)
      current_time <- current_time + rexp(1, rate=r[i])
    }
    # create recurrent events for this subject
    # last event is censoring
    subj_data <- data.frame(
      patient.id = i,
      time = c(event_times, C[i]),
      indicator = c(rep(1, length(event_times)), 0),
      disease_onset = disease_onset[i],
      C = C[i],
      xi = xi[i],
      Z = Z[i, ,drop=FALSE]
    )
    data_list <- c(data_list, list(subj_data))
  }

  simdat <- do.call(rbind, data_list)
  simdat
}
